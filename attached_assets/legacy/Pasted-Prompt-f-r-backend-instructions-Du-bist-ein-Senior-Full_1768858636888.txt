Prompt für backend instructions:

Du bist ein Senior Full-Stack Engineer. Refaktoriere und stabilisiere meinen bestehenden Prototypen. Es gibt NUR NOCH EINE EINZIGE STUDIEN-VARIANTE (kein A/B, keine Baseline-vs-Nudge-Logik). Der Flow ist fix:

Flow:
1) Landing / Pre-Survey (kurz)
2) Start Screen mit Aufgabenstellung (4 Zielkriterien)
3) ChatGPT-ähnliche Shopping-UI: 4 Requirements nacheinander
4) „Preview & Rate“ (6 Produkte, nur More like this / Not interested; keine Detailseiten per Klick)
5) Finaler Buyer’s Guide (ChatGPT-UI bleibt; Vergleichstabelle horizontal scrollbar)
6) „Weiter“-Button unter dem Buyer’s Guide -> Post-Survey (Outcome: welches Produkt würdest du kaufen? + Nudging/UX-Fragen)
7) Endscreen + Datenschutzhinweis/Kontakt + Hinweis auf Teilnehmer-ID (Session-ID)

WICHTIG: Ich brauche saubere Backend-Instrumentierung, nachvollziehbare Logs und eine aufgeräumte Projektstruktur. Alle Interaktionen müssen als Events protokolliert werden, mit Zeitstempeln, Session-ID, Step-Kontext und Payload. Ich will daraus später nachvollziehen können: Klick-Reihenfolge, Abweichungen von der Aufgabe, freie Texteingaben, Verweildauern pro Schritt, Gesamtzeit, final gewähltes Produkt.

========================================================
A) TECH-STACK / ARCHITEKTUR (entscheide pragmatisch)
========================================================
- Frontend: React (oder Next.js App Router, falls bereits vorhanden).
- Backend: Node.js (Express) ODER Next.js API Routes – nimm das, was in meinem Projekt bereits am besten passt.
- Persistenz: Bevorzugt SQLite (verlässlich, atomar, leicht exportierbar). Alternativ JSONL-Datei, falls SQLite nicht gut integrierbar ist.
- KEINE externen Services (kein Firebase, keine Drittanbieter-Analytics). Alles lokal im Replit-Projekt speicherbar.

========================================================
B) ORDNERSTRUKTUR AUFRÄUMEN
========================================================
Räume das Repo auf und stelle eine klare Struktur her. Ziel:
- Trennung Frontend / Backend / Shared / Data / Exports / Public Assets
- Verständliche Namen, keine Altlasten (baseline/nudge etc. entfernen)

Vorschlag (anpassen an vorhandenes Setup, aber konsistent halten):
/src
  /app (oder /pages)                 -> UI-Routing
  /components                         -> UI-Komponenten
  /features
    /study                             -> Study Screens + Flow-Logik
    /shoppingAssistant                 -> Chat-UI + Steps
  /lib
    /tracking                          -> Tracking-Client (event sender)
    /time                              -> Timing helpers
    /validation                        -> Input validation
  /server (falls Express)              -> API + DB + services
    /db                                -> sqlite init + migrations
    /services                          -> logging service, export service
    /routes                            -> endpoints
  /shared                              -> types/interfaces (Session, Event, etc.)
/public
  /images                              -> kaffeebild und UI assets
/data                                  -> sqlite file (oder logs)
/exports                               -> exportierte JSON/CSV Dateien
/scripts                               -> export scripts, summarizer
README.md                              -> Setup + Admin Export + Data Schema Doku

Entferne/umbennen:
- Alles was auf A/B, baseline, nudge-variant, conditionA/B etc. hinweist.
- Alle ungenutzten Komponenten/Seiten.
- Reduziere auf den einen Flow.

========================================================
C) SESSION-ID & PSEUDONYMISIERUNG
========================================================
- Jeder Besucher erhält beim ersten Laden eine Session-ID (UUID v4), die:
  - serverseitig erzeugt wird (bevorzugt)
  - und als HttpOnly Cookie gespeichert wird ODER im localStorage, falls Cookie-Handling zu aufwendig ist.
- Im UI wird diese Session-ID im Endscreen angezeigt („Teilnehmer-ID“), damit Nutzer ihre Datenlöschung anfragen können.
- Keine Klarnamen, keine E-Mail-Eingaben, keine Matrikelnummer.
- IP-Adresse NICHT speichern. User-Agent kann optional gespeichert werden (nur wenn wirklich nötig); sonst weglassen.
- Speichere zusätzlich:
  - created_at, last_seen_at
  - consent_status (ja/nein/abgebrochen) – je nach Flow

========================================================
D) EVENT-TRACKING: ALLES MUSS ALS EVENT GELÖGT WERDEN
========================================================
Erfasse Events für:
- Page/Step Enter, Step Exit
- Button Clicks (Continue, Skip falls vorhanden, Preview&Rate, Weiter)
- Auswahl in Requirements (inkl. Mehrfachauswahl, falls möglich)
- Freitext/Custom Input (WAS eingegeben wurde)
- „More like this“ / „Not interested“ Klicks (pro Produkt)
- Scroll/Verweildauer im Buyer’s Guide:
  - Zeit in diesem Screen
  - optional: scroll events (nur aggregiert, z.B. maxScrollDepth)
- Final Choice (welches Produkt würdest du kaufen?)
- Post-Survey Antworten
- Abbrüche / Reloads / Tab-Wechsel:
  - nutze Page Visibility API (visibilitychange) für „tab_hidden/tab_visible“

Event-Format (JSON):
{
  event_id: string (uuid),
  session_id: string,
  ts: ISO-8601 timestamp,
  step: string,                 // z.B. "presurvey", "task", "req_amount", "req_budget", "req_sustainability", "req_grind", "preview_rate", "buyers_guide", "postsurvey", "end"
  event_type: string,           // z.B. "step_enter", "step_exit", "click", "select", "input", "submit", "visibility"
  name: string,                 // canonical event name, snake_case
  payload: object               // details
}

Canonical event names (Beispiele, erweitere sauber):
- step_enter / step_exit
- presurvey_submit
- task_start_click
- requirement_amount_select
- requirement_budget_select
- requirement_sustainability_select
- requirement_grind_select
- requirement_custom_input
- preview_rate_open
- product_feedback_more_like_this
- product_feedback_not_interested
- buyers_guide_rendered
- buyers_guide_continue_click
- postsurvey_choice_submit
- postsurvey_submit
- visibility_hidden / visibility_visible
- session_end

WICHTIG: Bei jeder Auswahl muss gespeichert werden:
- raw_value (was User tatsächlich gewählt/geschrieben hat)
- normalized_value (was das System intern als gültig interpretiert)
Beispiel: User wählt 500g, aber Aufgabe verlangt 250g -> normalized_value = "250g", raw_value = "500g", und setze payload.deviation = true.

========================================================
E) TIMING / DAUER-MESSUNG
========================================================
Ich will:
- Gesamtzeit pro Session (start -> postsurvey_submit oder endscreen)
- Zeit pro Step (presurvey, task, req1..req4, preview_rate, buyers_guide, postsurvey)
- Buyer’s Guide Verweildauer besonders wichtig

Implementierung:
- Bei step_enter: timestamp speichern
- Bei step_exit: timestamp speichern
- Dauer = step_exit - step_enter
- Speichere Step-Dauern als:
  - entweder eigene Tabelle step_times
  - oder als berechnete Felder aus Events beim Export (aber zuverlässig!)

========================================================
F) DATENMODELL (SQLite bevorzugt)
========================================================
Wenn SQLite:
Tabelle sessions:
- session_id TEXT PRIMARY KEY
- created_at TEXT
- last_seen_at TEXT
- consent_status TEXT
- study_version TEXT DEFAULT "single_flow_v1"

Tabelle presurvey:
- session_id TEXT (FK)
- age INTEGER
- p7_frequency TEXT
- p8_used_for_shopping TEXT
- p9_familiarity INTEGER
- submitted_at TEXT

Tabelle events:
- event_id TEXT PRIMARY KEY
- session_id TEXT (FK)
- ts TEXT
- step TEXT
- event_type TEXT
- name TEXT
- payload TEXT (JSON string)

Tabelle outcome (postsurvey):
- session_id TEXT (FK)
- chosen_product_id TEXT      // P01..P06 oder interne IDs
- chosen_product_label TEXT   // der sichtbare Name
- confidence INTEGER optional (1-7)
- nudging_items JSON optional
- submitted_at TEXT

Optional: step_times:
- session_id TEXT
- step TEXT
- enter_ts TEXT
- exit_ts TEXT
- duration_ms INTEGER

Wenn JSONL statt SQLite:
- /data/events.jsonl (jede Zeile ein Event JSON)
- /data/sessions.jsonl (session start/end)
- /data/presurvey.jsonl
- /data/outcome.jsonl
Aber achte auf atomare Writes (append-only) und Locking.

========================================================
G) ADMIN-EXPORT / LESBARKEIT
========================================================
Ich brauche Exporte, die ich als Mensch lesen kann:
- JSON (sessions mit nested presurvey, outcome, step_durations, events_count)
- JSONL (raw events)
- optional CSV summary (eine Zeile pro Session)

Implementiere:
- /api/admin/export?format=json|jsonl|csv
- Basic Auth via ENV (ADMIN_USER, ADMIN_PASS) ODER ein Export-Token (ADMIN_TOKEN).
- Exportdateien nach /exports mit Timestamp im Dateinamen, z.B.:
  exports/sessions_YYYY-MM-DD_HH-mm.json
  exports/events_YYYY-MM-DD_HH-mm.jsonl
  exports/summary_YYYY-MM-DD_HH-mm.csv

Zusätzlich: /api/admin/health zeigt DB status und counts.

========================================================
H) ROBUSTHEIT / EDGE CASES
========================================================
- Reload: Session-ID bleibt gleich; logge "page_reload".
- Abbruch: wenn Nutzer Tab schließt, logge best-effort "session_end" (beforeunload) – kann unzuverlässig sein, aber versuchen.
- Network errors: Client-Tracking muss retry-fähig sein (Queue im memory/localStorage, flush bei next request).
- Datenschutz: speichere nur, was nötig ist. Keine IP. Keine Freitextfelder ohne Not – aber wenn Custom Input erlaubt ist, logge es; wenn möglich zusätzlich: truncate auf z.B. 250 Zeichen.

========================================================
I) DOKUMENTATION
========================================================
Aktualisiere README:
- Setup / Run
- Ordnerstruktur erklärt
- Data Schema erklärt (Sessions, Events, Outcome)
- Wie exportiert man Daten (Admin Export)
- Welche Felder sind primary outcome (chosen_product_id) und welche sind Prozessdaten

========================================================
J) AKTUALISIERUNG IM CODE (KONKRET)
========================================================
1) Entferne alle alten Variant/Condition-Flags.
2) Implementiere Session-ID Vergabe + persistente Speicherung.
3) Baue Tracking-Client: sendEvent(name, step, payload).
4) Instrumentiere jeden Step:
   - step_enter beim Render
   - step_exit beim Weiter/Navigate
5) Instrumentiere jede Interaktion:
   - selections: raw + normalized + deviation
   - clicks in preview/rate: pro product
6) Instrumentiere Buyer’s Guide Verweildauer:
   - enter/exit events
   - optional scroll depth
7) Speichere Presurvey und Postsurvey.
8) Implementiere Admin Export Endpoints.
9) Lege /data und /exports an und stelle sicher, dass Writes funktionieren.

Lieferung:
- Refaktorierter Code mit oben genannter Struktur
- Funktionierende Persistenz (SQLite bevorzugt)
- Export-Endpoints
- Beispiel-Exportdatei (Dummy-Daten) zum Prüfen
- Kurze Tests oder manuelle Testanleitung in README


